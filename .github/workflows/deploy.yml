name: CI/CD Pipeline

on:
  push:
    branches:
      - develop    # DEV environment
      - main       # PROD environment
  pull_request:
    branches:
      - develop
      - main

env:
  # Environment detection based on branch
  ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}
  AWS_REGION: us-east-1
  
  # Configuration flags (can be overridden via repository variables)
  TERRAFORM_ACTION: ${{ vars.TERRAFORM_ACTION || 'apply' }}  # apply or destroy
  DESTROY_INFRASTRUCTURE: ${{ vars.DESTROY_INFRASTRUCTURE || 'false' }}

# Required permissions for OIDC token
permissions:
  id-token: write   # Required for OIDC authentication with AWS
  contents: read    # Required to checkout repository
  actions: read     # Required for workflow execution
  security-events: write  # Required for security scanning

jobs:
  # Environment setup and validation
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env-setup.outputs.environment }}
      aws-role-arn: ${{ steps.env-setup.outputs.aws-role-arn }}
      should-build: ${{ steps.env-setup.outputs.should-build }}
      should-promote: ${{ steps.env-setup.outputs.should-promote }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Environment Setup and Validation
        id: env-setup
        run: |
          echo "Setting up environment for: ${{ env.ENVIRONMENT }}"
          
          # Environment-specific configuration
          if [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "aws-role-arn=${{ secrets.AWS_ROLE_ARN_PROD }}" >> $GITHUB_OUTPUT
            echo "should-build=false" >> $GITHUB_OUTPUT
            echo "should-promote=true" >> $GITHUB_OUTPUT
            echo "üöÄ PROD Environment - Image promotion workflow"
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "aws-role-arn=${{ secrets.AWS_ROLE_ARN_DEV }}" >> $GITHUB_OUTPUT
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "should-promote=false" >> $GITHUB_OUTPUT
            echo "üîß DEV Environment - Full build workflow"
          fi
          
          # Validate required secrets
          if [ -z "${{ secrets.AWS_ROLE_ARN_DEV }}" ] && [ "${{ env.ENVIRONMENT }}" = "dev" ]; then
            echo "‚ùå Missing AWS_ROLE_ARN_DEV secret"
            exit 1
          fi
          
          if [ -z "${{ secrets.AWS_ROLE_ARN_PROD }}" ] && [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
            echo "‚ùå Missing AWS_ROLE_ARN_PROD secret"
            exit 1
          fi
          
          # Configuration validation
          echo "Terraform Action: ${{ env.TERRAFORM_ACTION }}"
          echo "Destroy Infrastructure: ${{ env.DESTROY_INFRASTRUCTURE }}"
          
          # Validate Terraform action
          if [ "${{ env.TERRAFORM_ACTION }}" != "apply" ] && [ "${{ env.TERRAFORM_ACTION }}" != "destroy" ]; then
            echo "‚ùå Invalid TERRAFORM_ACTION: ${{ env.TERRAFORM_ACTION }}"
            echo "Valid values: apply, destroy"
            exit 1
          fi
          
          # Validate destroy infrastructure flag
          if [ "${{ env.DESTROY_INFRASTRUCTURE }}" != "true" ] && [ "${{ env.DESTROY_INFRASTRUCTURE }}" != "false" ]; then
            echo "‚ùå Invalid DESTROY_INFRASTRUCTURE: ${{ env.DESTROY_INFRASTRUCTURE }}"
            echo "Valid values: true, false"
            exit 1
          fi
          
          # PROD environment protection
          if [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "‚ùå PROD deployments not allowed from pull requests"
              exit 1
            fi
            
            if [ "${{ github.ref }}" != "refs/heads/main" ]; then
              echo "‚ùå PROD deployments only allowed from main branch"
              exit 1
            fi
            
            # Additional safety check for PROD destroy
            if [ "${{ env.DESTROY_INFRASTRUCTURE }}" = "true" ]; then
              echo "‚ö†Ô∏è PRODUCTION INFRASTRUCTURE DESTROY REQUESTED"
              echo "This is a destructive operation that will remove all production resources!"
              echo "Ensure this is intentional and you have proper backups."
              echo "Proceeding with PROD destroy operation..."
            fi
            
            echo "‚úÖ PROD environment protection checks passed"
          fi
          
          # Early validation for required Terraform files
          if [ ! -f "terraform/environments/${{ env.ENVIRONMENT }}.tfvars" ]; then
            echo "‚ùå Missing Terraform variables file: terraform/environments/${{ env.ENVIRONMENT }}.tfvars"
            exit 1
          fi
          
          if [ ! -f "terraform/backend-config/${{ env.ENVIRONMENT }}.hcl" ]; then
            echo "‚ùå Missing Terraform backend config: terraform/backend-config/${{ env.ENVIRONMENT }}.hcl"
            exit 1
          fi
          
          echo "‚úÖ Configuration validation completed successfully"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.env-setup.outputs.aws-role-arn }}
          role-session-name: GitHubActions-Setup
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS CLI setup
        run: |
          echo "üîß Verifying AWS CLI setup..."
          aws --version
          aws sts get-caller-identity
          echo "‚úÖ AWS CLI configured successfully"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ~1.0
          terraform_wrapper: false

      - name: Verify Terraform setup
        run: |
          echo "üîß Verifying Terraform setup..."
          terraform version
          echo "‚úÖ Terraform configured successfully"

      - name: Verify Maven setup
        working-directory: ./app
        run: |
          echo "üîß Verifying Maven setup..."
          ./mvnw --version
          echo "‚úÖ Maven configured successfully with Java 21"

  # Build and test job (DEV environment only)
  build-and-test:
    name: Build and Test (DEV)
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-build == 'true'
    outputs:
      jar-artifact: ${{ steps.build.outputs.jar-artifact }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven'

      - name: Restore Maven dependencies
        uses: actions/cache/restore@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Run Maven tests
        working-directory: ./app
        run: |
          echo "üß™ Running Maven tests..."
          ./mvnw test --batch-mode --fail-at-end
          echo "‚úÖ All tests passed"

      - name: Build application package
        id: build
        working-directory: ./app
        run: |
          echo "üî® Building application package..."
          ./mvnw package -DskipTests --batch-mode
          
          # Find the generated JAR file
          JAR_FILE=$(find target -name "*-runner.jar" | head -1)
          if [ -z "$JAR_FILE" ]; then
            echo "‚ùå No JAR file found in target directory"
            exit 1
          fi
          
          echo "jar-artifact=$JAR_FILE" >> $GITHUB_OUTPUT
          echo "‚úÖ Build completed: $JAR_FILE"

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: application-jar
          path: app/target/*-runner.jar
          retention-days: 1

  # Docker build job (DEV environment only)
  docker-build:
    name: Build Docker Image (DEV)
    runs-on: ubuntu-latest
    needs: [setup, build-and-test]
    if: needs.setup.outputs.should-build == 'true'
    outputs:
      image-tag: ${{ steps.docker.outputs.image-tag }}
      image-digest: ${{ steps.docker.outputs.image-digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: application-jar
          path: app/target/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.setup.outputs.aws-role-arn }}
          role-session-name: GitHubActions-DockerBuild
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        id: docker
        working-directory: ./app
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_DEV || 'ticketmaster-dev' }}
          IMAGE_TAG: ${{ github.sha }}-dev
        run: |
          echo "üê≥ Building Docker image..."
          
          # Build image using existing Dockerfile.jvm
          docker build -f src/main/docker/Dockerfile.jvm -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest-dev
          
          echo "üì§ Pushing image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest-dev
          
          # Get image digest for immutable reference
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG | cut -d'@' -f2)
          
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image-digest=$IMAGE_DIGEST" >> $GITHUB_OUTPUT
          echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # Image promotion job (PROD environment only)
  image-promotion:
    name: Promote Image (PROD)
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-promote == 'true'
    outputs:
      promoted-image-tag: ${{ steps.promote.outputs.promoted-image-tag }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.setup.outputs.aws-role-arn }}
          role-session-name: GitHubActions-ImagePromotion
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Promote DEV image to PROD
        id: promote
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY_DEV: ${{ vars.ECR_REPOSITORY_DEV || 'ticketmaster-dev' }}
          ECR_REPOSITORY_PROD: ${{ vars.ECR_REPOSITORY_PROD || 'ticketmaster-prod' }}
          DEV_IMAGE_TAG: ${{ github.sha }}-dev
          PROD_IMAGE_TAG: ${{ github.sha }}-prod
        run: |
          echo "üîÑ Promoting DEV image to PROD..."
          
          # Verify DEV image exists
          if ! aws ecr describe-images --repository-name $ECR_REPOSITORY_DEV --image-ids imageTag=$DEV_IMAGE_TAG >/dev/null 2>&1; then
            echo "‚ùå DEV image not found: $ECR_REPOSITORY_DEV:$DEV_IMAGE_TAG"
            echo "Please ensure the corresponding DEV build has completed successfully."
            exit 1
          fi
          
          # Pull DEV image
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$DEV_IMAGE_TAG
          
          # Retag for PROD
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$DEV_IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_PROD:$PROD_IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_DEV:$DEV_IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_PROD:latest-prod
          
          # Push PROD tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_PROD:$PROD_IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_PROD:latest-prod
          
          echo "promoted-image-tag=$PROD_IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Image promoted: $ECR_REGISTRY/$ECR_REPOSITORY_PROD:$PROD_IMAGE_TAG"
          echo "üìã Audit: Promoted $ECR_REPOSITORY_DEV:$DEV_IMAGE_TAG to $ECR_REPOSITORY_PROD:$PROD_IMAGE_TAG"

  # Infrastructure management
  infrastructure:
    name: Manage Infrastructure
    runs-on: ubuntu-latest
    needs: [setup]
    if: always() && !cancelled() && !failure()
    outputs:
      terraform-plan-exitcode: ${{ steps.plan.outputs.exitcode }}
      infrastructure-status: ${{ steps.apply-or-destroy.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.setup.outputs.aws-role-arn }}
          role-session-name: GitHubActions-Infrastructure
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ~1.0
          terraform_wrapper: false

      - name: Terraform Initialization and Planning
        id: init-and-plan
        working-directory: ./terraform
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          echo "üîß Initializing Terraform for $ENVIRONMENT environment..."
          
          # Initialize Terraform with environment-specific backend configuration
          terraform init \
            -backend-config="backend-config/${ENVIRONMENT}.hcl" \
            -reconfigure
          
          echo "‚úÖ Terraform initialized successfully"
          
          # Select or create workspace based on environment
          echo "üîß Configuring Terraform workspace..."
          if terraform workspace list | grep -q "$ENVIRONMENT"; then
            terraform workspace select "$ENVIRONMENT"
            echo "‚úÖ Selected existing workspace: $ENVIRONMENT"
          else
            terraform workspace new "$ENVIRONMENT"
            echo "‚úÖ Created new workspace: $ENVIRONMENT"
          fi
          
          echo "üîß Validating Terraform configuration..."
          terraform validate
          echo "‚úÖ Terraform configuration is valid"

      - name: Generate Terraform Plan
        id: plan
        working-directory: ./terraform
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          TF_VAR_file: "environments/${{ needs.setup.outputs.environment }}.tfvars"
        run: |
          echo "üìã Generating Terraform execution plan for $ENVIRONMENT environment..."
          
          # Generate plan based on configuration
          if [ "${{ env.DESTROY_INFRASTRUCTURE }}" = "true" ]; then
            echo "üî• Planning infrastructure DESTROY for $ENVIRONMENT environment"
            terraform plan \
              -destroy \
              -var-file="$TF_VAR_file" \
              -out="tfplan-destroy-$ENVIRONMENT" \
              -detailed-exitcode
            PLAN_EXITCODE=$?
          else
            echo "üèóÔ∏è Planning infrastructure APPLY for $ENVIRONMENT environment"
            terraform plan \
              -var-file="$TF_VAR_file" \
              -out="tfplan-apply-$ENVIRONMENT" \
              -detailed-exitcode
            PLAN_EXITCODE=$?
          fi
          
          echo "exitcode=$PLAN_EXITCODE" >> $GITHUB_OUTPUT
          
          # Interpret plan exit codes
          case $PLAN_EXITCODE in
            0)
              echo "‚úÖ No changes needed - infrastructure is up to date"
              ;;
            1)
              echo "‚ùå Terraform plan failed"
              exit 1
              ;;
            2)
              echo "üìù Changes detected - plan generated successfully"
              ;;
            *)
              echo "‚ùå Unexpected exit code: $PLAN_EXITCODE"
              exit 1
              ;;
          esac

      - name: Display Terraform Plan
        working-directory: ./terraform
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          echo "üìã Terraform Plan Summary for $ENVIRONMENT environment:"
          echo "=============================================="
          
          if [ "${{ env.DESTROY_INFRASTRUCTURE }}" = "true" ]; then
            if [ -f "tfplan-destroy-$ENVIRONMENT" ]; then
              terraform show "tfplan-destroy-$ENVIRONMENT"
            else
              echo "No destroy plan file found"
            fi
          else
            if [ -f "tfplan-apply-$ENVIRONMENT" ]; then
              terraform show "tfplan-apply-$ENVIRONMENT"
            else
              echo "No apply plan file found"
            fi
          fi

      - name: Apply or Destroy Infrastructure
        id: apply-or-destroy
        working-directory: ./terraform
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          # Only proceed if there are changes to apply (exit code 2) or if forced
          if [ "${{ steps.plan.outputs.exitcode }}" = "0" ]; then
            echo "‚úÖ No changes needed - skipping apply/destroy"
            echo "status=no-changes" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "${{ steps.plan.outputs.exitcode }}" != "2" ]; then
            echo "‚ùå Cannot proceed - plan failed or returned unexpected exit code"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Function to retry terraform operations with exponential backoff
          retry_terraform() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            local delay=5
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt of $max_attempts: $cmd"
              
              if eval "$cmd"; then
                echo "‚úÖ Command succeeded on attempt $attempt"
                return 0
              else
                local exit_code=$?
                echo "‚ùå Command failed on attempt $attempt (exit code: $exit_code)"
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "‚ùå All retry attempts exhausted"
                  return $exit_code
                fi
                
                echo "‚è≥ Waiting ${delay}s before retry..."
                sleep $delay
                delay=$((delay * 2))  # Exponential backoff
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Apply or destroy based on configuration
          if [ "${{ env.DESTROY_INFRASTRUCTURE }}" = "true" ]; then
            echo "üî• Destroying infrastructure for $ENVIRONMENT environment..."
            
            # Safety check for PROD environment
            if [ "$ENVIRONMENT" = "prod" ]; then
              echo "‚ö†Ô∏è PRODUCTION ENVIRONMENT DESTROY REQUESTED"
              echo "This will destroy all production infrastructure!"
              echo "Resources to be destroyed:"
              terraform show "tfplan-destroy-$ENVIRONMENT" | grep -E "# .* will be destroyed" || true
              echo "Proceeding with destroy operation in 10 seconds..."
              sleep 10
            fi
            
            # Retry terraform destroy with exponential backoff
            if retry_terraform "terraform apply tfplan-destroy-$ENVIRONMENT"; then
              echo "‚úÖ Infrastructure destroyed successfully"
              echo "status=destroyed" >> $GITHUB_OUTPUT
              
              # Verify destruction by checking if resources still exist
              echo "üîç Verifying infrastructure destruction..."
              if terraform show | grep -q "No state"; then
                echo "‚úÖ Infrastructure destruction verified - no resources remain"
              else
                echo "‚ö†Ô∏è Some resources may still exist - check manually"
              fi
              
            else
              echo "‚ùå Infrastructure destroy failed after all retry attempts"
              echo "status=destroy-failed" >> $GITHUB_OUTPUT
              
              # Provide troubleshooting information
              echo "üîç Troubleshooting Information:"
              echo "- Check AWS console for resources that may be preventing deletion"
              echo "- Verify IAM permissions for destroy operations"
              echo "- Check for dependencies between resources"
              echo "- Consider manual cleanup if automated destroy continues to fail"
              
              exit 1
            fi
            
          else
            echo "üèóÔ∏è Applying infrastructure changes for $ENVIRONMENT environment..."
            
            # Show what will be created/modified
            echo "üìã Resources to be applied:"
            terraform show "tfplan-apply-$ENVIRONMENT" | grep -E "# .* will be (created|updated)" || true
            
            # Retry terraform apply with exponential backoff
            if retry_terraform "terraform apply tfplan-apply-$ENVIRONMENT"; then
              echo "‚úÖ Infrastructure applied successfully"
              echo "status=applied" >> $GITHUB_OUTPUT
              
              # Display important outputs
              echo "üìã Infrastructure Outputs:"
              echo "=========================="
              terraform output
              
              # Verify critical resources are healthy
              echo "üîç Verifying infrastructure health..."
              
              # Check if ECS cluster is active
              if terraform output -raw ecs_cluster_arn >/dev/null 2>&1; then
                CLUSTER_ARN=$(terraform output -raw ecs_cluster_arn)
                echo "‚úÖ ECS Cluster created: $CLUSTER_ARN"
              fi
              
              # Check if RDS instance is available
              if terraform output -raw rds_endpoint >/dev/null 2>&1; then
                RDS_ENDPOINT=$(terraform output -raw rds_endpoint)
                echo "‚úÖ RDS Instance available: $RDS_ENDPOINT"
              fi
              
              # Check if ALB is active
              if terraform output -raw alb_dns_name >/dev/null 2>&1; then
                ALB_DNS=$(terraform output -raw alb_dns_name)
                echo "‚úÖ Application Load Balancer: $ALB_DNS"
              fi
              
            else
              echo "‚ùå Infrastructure apply failed after all retry attempts"
              echo "status=apply-failed" >> $GITHUB_OUTPUT
              
              # Provide troubleshooting information
              echo "üîç Troubleshooting Information:"
              echo "- Check AWS service limits and quotas"
              echo "- Verify IAM permissions for resource creation"
              echo "- Check for resource naming conflicts"
              echo "- Review Terraform state for partial deployments"
              echo "- Consider running 'terraform refresh' to sync state"
              
              exit 1
            fi
          fi

      - name: Infrastructure Status Summary
        if: always()
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          PLAN_EXITCODE: ${{ steps.plan.outputs.exitcode }}
          INFRA_STATUS: ${{ steps.apply-or-destroy.outputs.status }}
        run: |
          echo "üìä Infrastructure Management Summary"
          echo "===================================="
          echo "Environment: $ENVIRONMENT"
          echo "Terraform Action: ${{ env.TERRAFORM_ACTION }}"
          echo "Destroy Mode: ${{ env.DESTROY_INFRASTRUCTURE }}"
          echo "Plan Exit Code: $PLAN_EXITCODE"
          echo "Infrastructure Status: $INFRA_STATUS"
          
          case "$INFRA_STATUS" in
            "applied")
              echo "‚úÖ Infrastructure successfully applied"
              ;;
            "destroyed")
              echo "‚úÖ Infrastructure successfully destroyed"
              ;;
            "no-changes")
              echo "‚úÖ No infrastructure changes needed"
              ;;
            "apply-failed")
              echo "‚ùå Infrastructure apply failed"
              ;;
            "destroy-failed")
              echo "‚ùå Infrastructure destroy failed"
              ;;
            "failed")
              echo "‚ùå Infrastructure operation failed"
              ;;
            *)
              echo "‚ùì Unknown infrastructure status: $INFRA_STATUS"
              ;;
          esac

  # Deployment placeholder
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [setup, infrastructure]
    if: always() && !cancelled() && !failure() && needs.infrastructure.outputs.infrastructure-status != 'destroy-failed' && needs.infrastructure.outputs.infrastructure-status != 'destroyed'
    steps:
      - name: Deployment Placeholder
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          INFRA_STATUS: ${{ needs.infrastructure.outputs.infrastructure-status }}
        run: |
          echo "üöÄ Deployment to $ENVIRONMENT environment"
          echo "Infrastructure Status: $INFRA_STATUS"
          
          # Only proceed if infrastructure is ready
          case "$INFRA_STATUS" in
            "applied"|"no-changes")
              echo "‚úÖ Infrastructure is ready for deployment"
              echo "This will be implemented in subsequent tasks"
              ;;
            *)
              echo "‚ö†Ô∏è Infrastructure not ready for deployment: $INFRA_STATUS"
              echo "Skipping deployment step"
              ;;
          esac

  # Final status report
  status:
    name: Pipeline Status
    runs-on: ubuntu-latest
    needs: [setup, build-and-test, docker-build, image-promotion, infrastructure, deploy]
    if: always()
    steps:
      - name: Report Pipeline Status
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          INFRA_STATUS: ${{ needs.infrastructure.outputs.infrastructure-status }}
          TERRAFORM_PLAN_EXITCODE: ${{ needs.infrastructure.outputs.terraform-plan-exitcode }}
        run: |
          echo "üìä Pipeline Execution Summary"
          echo "Environment: $ENVIRONMENT"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Terraform Action: ${{ env.TERRAFORM_ACTION }}"
          echo "Destroy Mode: ${{ env.DESTROY_INFRASTRUCTURE }}"
          
          if [ "$ENVIRONMENT" = "dev" ]; then
            echo ""
            echo "DEV Pipeline Status:"
            echo "- Setup: ${{ needs.setup.result }}"
            echo "- Build & Test: ${{ needs.build-and-test.result }}"
            echo "- Docker Build: ${{ needs.docker-build.result }}"
          else
            echo ""
            echo "PROD Pipeline Status:"
            echo "- Setup: ${{ needs.setup.result }}"
            echo "- Image Promotion: ${{ needs.image-promotion.result }}"
          fi
          
          echo "- Infrastructure: ${{ needs.infrastructure.result }} (Status: $INFRA_STATUS, Plan: $TERRAFORM_PLAN_EXITCODE)"
          echo "- Deploy: ${{ needs.deploy.result }}"
          
          # Detailed infrastructure status
          echo ""
          echo "Infrastructure Details:"
          case "$INFRA_STATUS" in
            "applied")
              echo "‚úÖ Infrastructure successfully provisioned/updated"
              ;;
            "destroyed")
              echo "‚úÖ Infrastructure successfully destroyed"
              ;;
            "no-changes")
              echo "‚úÖ Infrastructure up to date - no changes needed"
              ;;
            "apply-failed")
              echo "‚ùå Infrastructure provisioning failed"
              ;;
            "destroy-failed")
              echo "‚ùå Infrastructure destruction failed"
              ;;
            "failed")
              echo "‚ùå Infrastructure operation failed"
              ;;
            *)
              echo "‚ùì Unknown infrastructure status: $INFRA_STATUS"
              ;;
          esac
          
          # Check for any failures
          if [ "${{ contains(needs.*.result, 'failure') }}" = "true" ]; then
            echo ""
            echo "‚ùå Pipeline completed with failures"
            exit 1
          else
            echo ""
            echo "‚úÖ Pipeline completed successfully"
          fi